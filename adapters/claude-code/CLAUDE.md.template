<!-- ACCORD START — do not edit this block manually. Managed by accord. -->

# Accord Protocol Rules

You are an AI coding agent participating in the **{{PROJECT_NAME}}** project via the Accord protocol. Follow these rules for all cross-module coordination.

## Project Modules

- **Project**: {{PROJECT_NAME}}
- **Services**: {{SERVICE_LIST}}
- **Sub-modules**: {{MODULE_LIST}}
- **External contracts**: `{{CONTRACTS_DIR}}`
- **Internal contracts**: `{{INTERNAL_CONTRACTS_DIR}}`
- **Communications**: `{{COMMS_DIR}}`
- **Sync mode**: `{{SYNC_MODE}}`
- **Full module config**: `.accord/config.yaml` (see `path:` fields for directory mapping)

Each service and sub-module is an **independent boundary**. Every cross-boundary change must go through the Accord protocol.

## CRITICAL: Module Boundary Rules

**Each module is an independent boundary. You work on ONE module per session.**

1. At session start, determine which module the user wants to work on — infer from their request or ask
2. Announce: "I'll be working as the **{module}** module, only modifying files under `{path}/`"
3. You MUST NOT modify source code, configuration, or any files outside your working module's directory
4. If a feature requires changes in another module's code, you MUST create a request via the Accord protocol
5. When the user asks for a feature that spans multiple modules, explicitly tell them which parts you can implement (your module) and which parts require requests to other modules
6. You may READ other modules' contracts and code for reference, but NEVER edit them

## ON START (Every Session)

When a conversation starts:

1. Read `.accord/config.yaml` to understand the module structure, paths, and repo model
2. If multi-repo: run `git pull` to sync latest changes
3. If `.accord/hub/` exists: run `bash ~/.accord/accord-sync.sh pull --target-dir .` to sync from hub
4. Determine your working module from the user's first message
5. Announce your working module and directory scope
6. Check your inbox: `{{COMMS_DIR}}inbox/{your-module}/`
7. For each request file found, read the YAML frontmatter
8. Report to the user:
   - Your working module and directory scope
   - Number of pending/approved requests
   - Summary of each (id, from, type, priority, status)
9. Check `git log --oneline -10` for recent contract changes

## ON_ACTION (Sync Before Operations)

**If sync mode is `on-action` AND repo model is `multi-repo`:** Before starting any implementation task, run a quick sync:

1. `git pull` to get latest changes
2. If `.accord/hub/` exists: run `bash ~/.accord/accord-sync.sh pull --target-dir .` to sync from hub
3. Check inbox for any new requests that might affect the current task
4. If new relevant requests exist, inform the user before proceeding

**If monorepo:** Comms are local — just re-check the inbox directory for new files. No `git pull` needed for comms (though pulling for code sync is fine).

**If sync mode is `manual` or `auto-poll`:** Skip this — the user handles sync themselves.

## Contract Rules

### External Contracts
- Location: `{{CONTRACTS_DIR}}{module}.yaml` (OpenAPI 3.0)
- You may ONLY modify the contract for your working module
- Never edit another module's contract directly — create a request instead
- Proposed changes use `x-accord-status: proposed` + `x-accord-request: {id}` annotations

### Internal Contracts
- Location: `{{INTERNAL_CONTRACTS_DIR}}{module}.md`
- You may ONLY modify contracts for your working module
- Never edit another module's contract directly — create a request instead

## ON_NEED_INTERFACE (Cross-Boundary Request)

When you need an API or interface that doesn't exist in another module's contract:

### External (cross-service)
1. Check `{{CONTRACTS_DIR}}{target-module}.yaml` to confirm the API doesn't exist
2. Create a request file using the template in `{{COMMS_DIR}}TEMPLATE.md`
3. Set `scope: external`, assign a unique ID `req-{NNN}-{description}`
4. Place in `{{COMMS_DIR}}inbox/{target-module}/`
5. Optionally annotate `{{CONTRACTS_DIR}}{target-module}.yaml` with `x-accord-status: proposed`
6. `git add .accord/` + `git commit -m "comms({target}): request - {summary}"`
7. Multi-repo only: `git push` (monorepo: request is already visible locally)
8. Tell the user: "Created request {id} to {target}. Needs their approval."
9. Do NOT block — continue with mock data or TODO markers

### Internal (cross-module within same service)
1. Check `{{INTERNAL_CONTRACTS_DIR}}{target-module}.md` to confirm the interface doesn't exist
2. Create a request file using the template in `{{COMMS_DIR}}TEMPLATE.md`
3. Set `scope: internal`, assign a unique ID `req-{NNN}-{description}`
4. Place in `{{COMMS_DIR}}inbox/{target-module}/`
5. `git add .accord/` + `git commit -m "comms({target-module}): request - {summary}"`
6. Monorepo: no push needed — request is immediately visible locally
7. Tell the user: "Created internal request {id} to module {target-module}."
8. Do NOT block — continue with mock data or TODO markers

## ON_APPROVED_REQUEST (Processing Requests)

When you find an approved request in your inbox:

1. Read the full request file
2. Present it to the user for confirmation before starting
3. If user confirms:
   a. Update status to `in-progress`, commit
   b. Implement the requested change
   c. Update the relevant contract:
      - External: `{{CONTRACTS_DIR}}{your-module}.yaml` (remove `x-accord-status: proposed`)
      - Internal: `{{INTERNAL_CONTRACTS_DIR}}{your-module}.md`
   d. Update status to `completed`
   e. Move request to archive directory
   f. `git add .` + `git commit -m "comms({your-module}): completed - {request-id}"`
   g. Multi-repo only: `git push`
4. If user declines: leave it as approved for later

## ON_COMPLETE (Request Completion)

Before marking a request as completed, verify:
1. The contract file has been updated
2. The implementation matches the contract
3. Then: update status → move to archive → `git add . && git commit`
4. Multi-repo only: `git push`
5. Tell the user: "Completed request {id}. Contract updated."

## ON_SCAN (Contract Generation)

When the user asks to generate or update contracts:
1. Use the `/accord-scan` command or follow `protocol/scan/SCAN_INSTRUCTIONS.md`
2. All generated contracts start as `status: draft`
3. Run validators after generation
4. Do NOT auto-commit — let the user review first

## ON_SYNC (Multi-Repo Only)

For `accord sync push`:
1. Sync contracts and requests to the hub repo
2. Commit and push the hub

For `accord sync pull`:
1. Pull latest from the hub repo
2. Check hub inbox for new requests
3. Report findings to the user

## ON_DISPATCH (Multi-Module Feature — MANDATORY)

**When the user requests a feature that spans multiple modules, you MUST NOT implement all changes yourself.** Instead, separate the work by module boundary:

- **Your module's part**: implement directly
- **Other modules' parts**: create Accord requests via `{{COMMS_DIR}}inbox/{target-module}/`
- **If the user insists on doing it all at once**: use subagents (Task tool), with each subagent scoped to one module's directory only

### Step 1: Analyze scope

1. Read `.accord/config.yaml` to identify all modules and their paths
2. Read relevant contracts in `{{CONTRACTS_DIR}}` and `{{INTERNAL_CONTRACTS_DIR}}`
3. Determine which modules are involved and what each needs to do
4. Identify dependencies: does module A need module B's interface first?

### Step 2: Plan the dispatch

Build a dispatch plan:
```
Feature: "Add device search to nac-admin"
  1. [device-manager] Add GET /api/devices/search → update contract
  2. [nac-admin]      Call new search API → implement admin feature
  Dependency: step 2 depends on step 1
```

Present this plan to the user for approval before proceeding.

### Step 3: Dispatch subagents

For each module's work, spawn a subagent using the Task tool:

- **Scope the subagent**: tell it which module it's acting as, and restrict file changes to that module's directory
- **Provide context**: include the relevant contract and the request description
- **Contract updates**: the subagent must update the module's contract if the interface changes
- **Sequential if dependent**: if module B needs module A's new interface, dispatch A first, wait for completion, then dispatch B with the updated contract
- **Parallel if independent**: if modules have no dependency, dispatch them in parallel

Example subagent prompt:
```
You are working as the device-manager module.
Your module directory: device-manager/
Your contract: .accord/contracts/device-manager.yaml

Task: Add a GET /api/devices/search endpoint that accepts query params
(name, type, status) and returns matching devices.

Rules:
- Only modify files under device-manager/
- Update .accord/contracts/device-manager.yaml with the new endpoint
- Follow existing code patterns in the module
```

### Step 4: Reconcile

After all subagents complete:
1. Verify all contracts were updated correctly
2. If the feature created cross-boundary requests, ensure they follow the Accord protocol
3. Run `/accord-validate` to check consistency
4. Report results to the user

### When NOT to dispatch

- Simple single-module changes — just implement directly
- The user explicitly wants to handle coordination manually
- The feature scope is unclear — ask the user to clarify first

## ON_CONFLICT

If `git pull` results in a merge conflict on any contract or request file:
1. Do NOT auto-resolve
2. Tell the user: "Contract conflict detected in {file}. Manual resolution required."
3. Show both versions if possible
4. Wait for user instruction

## Debug Logging

**If `settings.debug` is `true` in `.accord/config.yaml`**, write structured log entries for every protocol action you perform. This enables tracing and debugging of cross-boundary coordination.

### Setup

At session start, if debug is enabled:
1. Generate a session ID: `{YYYY-MM-DD}T{HH-MM-SS}_{your-module}` (using current time)
2. Create log file: `.accord/log/{session-id}.jsonl`
3. Write a `session_start` entry

### Log Format

Append one JSON object per line (JSONL). Required fields: `ts`, `session`, `module`, `action`, `category`, `detail`. Optional: `files`, `request_id`, `status_from`, `status_to`.

```json
{"ts":"2026-02-10T14:30:00Z","session":"2026-02-10T14-30-00_device-manager","module":"device-manager","action":"inbox_check","category":"comms","detail":"Found 2 pending requests"}
```

### When to Log

| Category | Actions |
|----------|---------|
| `lifecycle` | `session_start`, `session_end`, `module_selected`, `config_read` |
| `comms` | `inbox_check`, `request_create`, `request_approve`, `request_reject`, `request_start`, `request_complete`, `request_archive` |
| `contract` | `contract_read`, `contract_update`, `contract_annotate`, `contract_scan`, `contract_validate` |
| `git` | `git_pull`, `git_push`, `git_commit`, `git_conflict` |
| `scan` | `scan_start`, `scan_complete`, `scan_validate` |

For state transitions (approve/reject/start/complete), include `request_id`, `status_from`, and `status_to`.

### Viewing Logs

Use `/accord-log` to check debug status, list log files, and show summaries. Use `accord-log.sh` to launch the web-based timeline viewer.

See `protocol/debug/LOG_FORMAT.md` for the full specification.

## State Machine Reference

```
pending → approved      (human review required)
pending → rejected      (with reason)
approved → in-progress  (agent starts work)
in-progress → completed (contract updated, request archived)
```

## Commit Format

```
comms({module}): {action} - {summary}
contract({module}): {action} - {summary}
```

Actions: `request`, `approved`, `rejected`, `in-progress`, `completed`, `update`

<!-- ACCORD END -->
